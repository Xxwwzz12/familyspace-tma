// backend/src/services/telegram-auth.service.ts
import * as crypto from 'crypto';
import { TelegramUser } from '../types/telegram';

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
interface ValidationOptions {
  disableTimeCheck?: boolean;
  debug?: boolean;
}

// –§–æ–ª–±—ç–∫-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–ª—è dev
const FALLBACK_USER: TelegramUser = {
  id: 123456789,
  first_name: 'Test',
  last_name: 'User',
  username: 'testuser',
  language_code: 'en',
  is_premium: true,
  allows_write_to_pm: true
};

// –í–†–ï–ú–ï–ù–ù–û: –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º –æ—Ç–ª–∞–¥–∫—É —Ö—ç—à–∞
const DEBUG_SKIP_HASH_CHECK = process.env.DEBUG_SKIP_HASH_CHECK === 'true' || true; // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ true

// üîß –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø - –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
const DEBUG_SKIP_TIME_CHECK = true; // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É —Å—Ç—Ä–æ–∫—É

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∂–∏–º–∞ –æ—Ç–ª–∞–¥–∫–∏ —Ö—ç—à–∞
const isHashCheckDisabled = (): boolean => {
  return DEBUG_SKIP_HASH_CHECK;
};

function validateEnvironmentVariables(debug = false): string {
  if (!process.env.BOT_TOKEN) {
    if (debug) console.error('‚ùå BOT_TOKEN not set');
    const envKeys = Object.keys(process.env).sort();
    if (debug) console.log('üìã Available env:', envKeys.join(', '));
    throw new Error('BOT_TOKEN is not set in environment variables');
  }
  const BOT_TOKEN = process.env.BOT_TOKEN.trim();
  if (!BOT_TOKEN) throw new Error('BOT_TOKEN is empty or whitespace');
  if (!BOT_TOKEN.match(/^\d+:[a-zA-Z0-9_-]+$/)) {
    if (debug) console.error('‚ùå BOT_TOKEN has unexpected format');
    throw new Error('Invalid BOT_TOKEN format. Expected "number:secret"');
  }
  if (debug) {
    const masked = BOT_TOKEN.substring(0, 5) + '...' + BOT_TOKEN.substring(BOT_TOKEN.length - 5);
    console.log('‚úÖ BOT_TOKEN (masked):', masked, 'len=', BOT_TOKEN.length);
  }
  
  // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏
  if (isHashCheckDisabled()) {
    console.warn('‚ö†Ô∏è  DEBUG_SKIP_HASH_CHECK is enabled - HASH VERIFICATION IS DISABLED');
    console.warn('‚ö†Ô∏è  This should only be used for temporary debugging purposes');
  }
  
  // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
  if (DEBUG_SKIP_TIME_CHECK) {
    console.warn('‚ö†Ô∏è  DEBUG_SKIP_TIME_CHECK is enabled - TIME VERIFICATION IS DISABLED');
    console.warn('‚ö†Ô∏è  This should only be used for temporary debugging purposes');
  }
  
  return BOT_TOKEN;
}

// üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å —É—á–µ—Ç–æ–º signature
function extractAndPrepareParams(initData: string, debug = false) {
  const params: Record<string, string> = {};
  const rawParams: Record<string, string> = {};
  const cleaned = initData.startsWith('?') ? initData.slice(1) : initData;
  const pairs = cleaned.split('&').filter(Boolean);

  for (const pair of pairs) {
    const idx = pair.indexOf('=');
    const key = idx >= 0 ? pair.slice(0, idx) : pair;
    const value = idx >= 0 ? pair.slice(idx + 1) : '';
    rawParams[key] = value; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª (URL-encoded)
  }

  const hash = rawParams['hash'] ?? (new URLSearchParams(cleaned).get('hash') ?? '');
  if (!hash) throw new Error('Missing hash in initData');

  // üîß –ò–°–ö–õ–Æ–ß–ê–ï–ú signature –∏–∑ –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
  const allowedKeys = ['auth_date', 'query_id', 'user'];
  for (const k of Object.keys(rawParams)) {
    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º hash –∏ signature
    if (k === 'hash' || k === 'signature') continue;
    
    if (allowedKeys.includes(k)) {
      try {
        params[k] = decodeURIComponent(rawParams[k]);
      } catch {
        params[k] = rawParams[k];
      }
    }
  }

  if (debug || isHashCheckDisabled()) {
    console.log('[TelegramAuth] Decoded params for logic:', params);
    console.log('[TelegramAuth] Raw params (URL-encoded):', rawParams);
    console.log('[TelegramAuth] Received hash:', hash);
    if (rawParams['signature']) {
      console.log('‚ö†Ô∏è  Found signature parameter (excluded from data-check-string):', rawParams['signature']);
    }
  }

  return { params, rawParams, hash };
}

// üîß –§–£–ù–ö–¶–ò–Ø: –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ data-check-string —Å —Ä–∞–∑–Ω—ã–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏
function buildDataCheckStringVariants(rawParams: Record<string, string>, debug = false) {
  const variants: Array<{name: string; dcs: string}> = [];
  
  // –í–∞—Ä–∏–∞–Ω—Ç 1: –∏—Å–∫–ª—é—á–∞–µ–º hash –∏ signature (—Ç–µ–∫—É—â–∏–π)
  const checkParams1 = new URLSearchParams();
  for (const [key, value] of Object.entries(rawParams)) {
    if (key === 'hash' || key === 'signature') continue;
    const allowedKeys = ['auth_date', 'query_id', 'user'];
    if (allowedKeys.includes(key)) {
      checkParams1.append(key, value);
    }
  }
  const sortedEntries1 = Array.from(checkParams1.entries()).sort(([a], [b]) => a.localeCompare(b));
  const dcs1 = sortedEntries1.map(([key, value]) => `${key}=${value}`).join('\n');
  variants.push({ name: 'exclude_hash_and_signature', dcs: dcs1 });
  
  // –í–∞—Ä–∏–∞–Ω—Ç 2: –∏—Å–∫–ª—é—á–∞–µ–º —Ç–æ–ª—å–∫–æ hash, –æ—Å—Ç–∞–≤–ª—è–µ–º signature
  const checkParams2 = new URLSearchParams();
  for (const [key, value] of Object.entries(rawParams)) {
    if (key === 'hash') continue;
    const allowedKeys = ['auth_date', 'query_id', 'user', 'signature'];
    if (allowedKeys.includes(key)) {
      checkParams2.append(key, value);
    }
  }
  const sortedEntries2 = Array.from(checkParams2.entries()).sort(([a], [b]) => a.localeCompare(b));
  const dcs2 = sortedEntries2.map(([key, value]) => `${key}=${value}`).join('\n');
  variants.push({ name: 'exclude_only_hash', dcs: dcs2 });
  
  // –í–∞—Ä–∏–∞–Ω—Ç 3: –≤–∫–ª—é—á–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—Ä–æ–º–µ hash
  const checkParams3 = new URLSearchParams();
  for (const [key, value] of Object.entries(rawParams)) {
    if (key === 'hash') continue;
    checkParams3.append(key, value);
  }
  const sortedEntries3 = Array.from(checkParams3.entries()).sort(([a], [b]) => a.localeCompare(b));
  const dcs3 = sortedEntries3.map(([key, value]) => `${key}=${value}`).join('\n');
  variants.push({ name: 'include_all_except_hash', dcs: dcs3 });

  if (debug || isHashCheckDisabled()) {
    console.log('üìã Data-check-string –≤–∞—Ä–∏–∞–Ω—Ç—ã:');
    variants.forEach((variant, index) => {
      console.log(`\nüî§ –í–∞—Ä–∏–∞–Ω—Ç ${index + 1}: ${variant.name}`);
      console.log('```');
      console.log(variant.dcs);
      console.log('```');
      console.log(`üìè –î–ª–∏–Ω–∞: ${variant.dcs.length}`);
    });
  }

  return variants;
}

// üîß –§–£–ù–ö–¶–ò–Ø: –°–æ–∑–¥–∞–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
function buildSecretKeyVariants(botToken: string, debug = false) {
  const variants = [
    {
      name: 'SHA256(botToken)',
      key: crypto.createHash('sha256').update(botToken).digest()
    },
    {
      name: 'HMAC_SHA256("WebAppData", botToken)',
      key: crypto.createHmac('sha256', 'WebAppData').update(botToken).digest()
    },
    {
      name: 'HMAC_SHA256(botToken, "WebAppData")', 
      key: crypto.createHmac('sha256', botToken).update('WebAppData').digest()
    },
    {
      name: 'SHA256("WebAppData" + botToken)',
      key: crypto.createHash('sha256').update('WebAppData' + botToken).digest()
    },
    {
      name: 'BOT_TOKEN (raw)',
      key: botToken
    }
  ];

  if (debug || isHashCheckDisabled()) {
    console.log('üîê –í–∞—Ä–∏–∞–Ω—Ç—ã —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞:');
    variants.forEach((variant, index) => {
      const keyDesc = Buffer.isBuffer(variant.key) 
        ? `Buffer(len=${variant.key.length}, hex=${variant.key.toString('hex').substring(0, 16)}...)`
        : `String(len=${variant.key.length})`;
      console.log(`  ${index + 1}. ${variant.name}: ${keyDesc}`);
    });
  }

  return variants;
}

// üîß –§–£–ù–ö–¶–ò–Ø: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π
function testAllHashCombinations(
  secretKeyVariants: Array<{name: string; key: Buffer | string}>,
  dataCheckStringVariants: Array<{name: string; dcs: string}>,
  receivedHash: string,
  debug = false
): {success: boolean; secretVariant?: string; dcsVariant?: string} {
  console.log('\nüéØ –¢–ï–°–¢–ò–†–£–ï–ú –í–°–ï –ö–û–ú–ë–ò–ù–ê–¶–ò–ò –•–≠–®–ï–ô:');
  console.log('================================');
  
  let foundMatch = false;
  let matchDetails: {secretVariant?: string; dcsVariant?: string} = {};

  for (const secretVariant of secretKeyVariants) {
    for (const dcsVariant of dataCheckStringVariants) {
      try {
        const testHash = crypto.createHmac('sha256', secretVariant.key as crypto.BinaryLike)
          .update(dcsVariant.dcs)
          .digest('hex');
        
        const matches = testHash === receivedHash;
        
        if (debug || isHashCheckDisabled() || matches) {
          console.log(`\nüîç TEST: ${secretVariant.name} + ${dcsVariant.name}`);
          console.log(`üîê Expected: ${testHash}`);
          console.log(`üîê Received: ${receivedHash}`);
          console.log(`‚úÖ Match: ${matches ? 'üéâ –î–ê!' : '‚ùå –Ω–µ—Ç'}`);
        }
        
        if (matches && !foundMatch) {
          console.log('üéâ –ù–ê–ô–î–ï–ù–ê –†–ê–ë–û–ß–ê–Ø –ö–û–ú–ë–ò–ù–ê–¶–ò–Ø!');
          foundMatch = true;
          matchDetails = {
            secretVariant: secretVariant.name,
            dcsVariant: dcsVariant.name
          };
        }
      } catch (error) {
        if (debug || isHashCheckDisabled()) {
          console.log(`‚ùå –û—à–∏–±–∫–∞ –≤ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏: ${secretVariant.name} + ${dcsVariant.name}`);
          console.log(`   Error: ${error}`);
        }
      }
    }
  }

  if (!foundMatch) {
    console.log('\n‚ùå –ù–∏ –æ–¥–Ω–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞');
  }

  return { success: foundMatch, ...matchDetails };
}

// üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –í–ê–õ–ò–î–ê–¶–ò–ò
export async function validateInitData(initData: string, options: ValidationOptions = {}): Promise<TelegramUser> {
  const { disableTimeCheck = false, debug = false } = options;
  const hashCheckDisabled = isHashCheckDisabled();
  
  if (debug || hashCheckDisabled) {
    console.log('=== TELEGRAM AUTH DEBUG START ===');
    console.log('[TelegramAuth] raw initData:', initData);
    console.log('[TelegramAuth] options:', { disableTimeCheck, debug });
    if (hashCheckDisabled) {
      console.warn('üö® HASH VERIFICATION DISABLED - DEBUG_SKIP_HASH_CHECK=true');
    }
    if (DEBUG_SKIP_TIME_CHECK) {
      console.warn('üö® TIME VERIFICATION DISABLED - DEBUG_SKIP_TIME_CHECK=true');
    }
  }

  // dev fallback
  if (initData.includes('hash=development_fallback_hash')) {
    if (debug || hashCheckDisabled) console.log('[TelegramAuth] development fallback');
    const qs = new URLSearchParams(initData);
    const userParam = qs.get('user');
    if (userParam) {
      try {
        const u = JSON.parse(decodeURIComponent(userParam));
        if (debug || hashCheckDisabled) console.log('[TelegramAuth] fallback user:', u);
        return u;
      } catch (err) {
        if (debug || hashCheckDisabled) console.warn('failed parse fallback user', err);
      }
    }
    return FALLBACK_USER;
  }

  const BOT_TOKEN = validateEnvironmentVariables(debug || hashCheckDisabled);
  const { params, rawParams, hash } = extractAndPrepareParams(initData, debug || hashCheckDisabled);

  if (!params.auth_date) throw new Error('Missing auth_date');
  const authDate = parseInt(params.auth_date, 10);
  if (isNaN(authDate)) throw new Error('Invalid auth_date');

  // üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –í–†–ï–ú–ï–ù–ò –° –í–û–ó–ú–û–ñ–ù–û–°–¢–¨–Æ –û–¢–ö–õ–Æ–ß–ï–ù–ò–Ø
  const MAX_AUTH_AGE = 30 * 60; // 30 –º–∏–Ω—É—Ç –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
  
  if (!DEBUG_SKIP_TIME_CHECK && !disableTimeCheck) {
    const now = Math.floor(Date.now() / 1000);
    const diff = now - authDate;
    const timeDiffMinutes = Math.floor(diff / 60);
    
    if (debug || hashCheckDisabled) {
      console.log('[TelegramAuth] auth_date:', new Date(authDate * 1000).toISOString());
      console.log('[TelegramAuth] current time:', new Date(now * 1000).toISOString());
      console.log('[TelegramAuth] time difference:', timeDiffMinutes, 'minutes');
      console.log('[TelegramAuth] maximum allowed age:', 30, 'minutes');
    }
    
    // üîß –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø
    if (!DEBUG_SKIP_TIME_CHECK && diff > MAX_AUTH_AGE) {
      throw new Error(`Auth date too old (${timeDiffMinutes} minutes). Maximum allowed: 30 minutes`);
    }
  } else {
    const now = Math.floor(Date.now() / 1000);
    const diff = now - authDate;
    const timeDiffMinutes = Math.floor(diff / 60);
    
    if (debug || hashCheckDisabled) {
      console.log('[TelegramAuth] auth_date:', new Date(authDate * 1000).toISOString());
      console.log('[TelegramAuth] current time:', new Date(now * 1000).toISOString());
      console.log('[TelegramAuth] time difference:', timeDiffMinutes, 'minutes');
      console.log('[TelegramAuth] ‚ö†Ô∏è  TIME CHECK DISABLED');
    }
  }

  // üîß –¢–ï–°–¢–ò–†–£–ï–ú –í–°–ï –í–ê–†–ò–ê–ù–¢–´ –•–≠–®–ï–ô
  const secretKeyVariants = buildSecretKeyVariants(BOT_TOKEN, debug || hashCheckDisabled);
  const dataCheckStringVariants = buildDataCheckStringVariants(rawParams, debug || hashCheckDisabled);
  
  const testResult = testAllHashCombinations(
    secretKeyVariants, 
    dataCheckStringVariants, 
    hash, 
    debug || hashCheckDisabled
  );

  // üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –ü–†–û–í–ï–†–ö–ò –•–≠–®–ê
  if (hashCheckDisabled) {
    console.warn('‚ö†Ô∏è  SKIPPING HASH VERIFICATION - DEBUG_SKIP_HASH_CHECK=true');
    console.warn('‚ö†Ô∏è  This should only be used for temporary debugging');
    
    if (testResult.success) {
      console.log(`üéâ –†–∞–±–æ—á–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–∞–π–¥–µ–Ω–∞: ${testResult.secretVariant} + ${testResult.dcsVariant}`);
    }
    
  } else {
    if (testResult.success) {
      console.log(`üéâ –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–±–æ—á—É—é –∫–æ–º–±–∏–Ω–∞—Ü–∏—é: ${testResult.secretVariant} + ${testResult.dcsVariant}`);
      console.log('üîê Hash validation successful ‚úÖ');
    } else {
      console.error('‚ùå Hash validation failed! –ù–∏ –æ–¥–Ω–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞');
      console.log('üîç Troubleshooting suggestions:');
      console.log('   1. Check that BOT_TOKEN is correct');
      console.log('   2. Verify initData is passed exactly as received from Telegram');
      console.log('   3. Check if BOT_TOKEN matches the one used in Telegram WebApp');
      console.log('   4. Verify that no URL encoding/decoding happens in between');
      throw new Error(`Invalid hash. None of the ${secretKeyVariants.length * dataCheckStringVariants.length} combinations matched received hash`);
    }
  }

  // –ü–∞—Ä—Å–∏–º user JSON (–∏–∑ decoded params) - —ç—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ
  try {
    const userJson = params.user;
    if (!userJson) throw new Error('Missing user JSON');
    if (debug || hashCheckDisabled) console.log('[TelegramAuth] userJson to parse:', userJson);
    const user = JSON.parse(userJson) as TelegramUser;
    if (debug || hashCheckDisabled) {
      console.log('[TelegramAuth] parsed user:', user);
      if (hashCheckDisabled) {
        console.warn('‚úÖ AUTHENTICATION SUCCESSFUL (HASH CHECK SKIPPED)');
      } else {
        console.log('‚úÖ AUTHENTICATION SUCCESSFUL');
      }
    }
    return user;
  } catch (err) {
    throw new Error(`Invalid user JSON: ${err instanceof Error ? err.message : String(err)}`);
  }
}

// –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è —Ç–µ—Å—Ç–æ–≤
export { 
  validateEnvironmentVariables, 
  extractAndPrepareParams, 
  buildDataCheckStringVariants, 
  buildSecretKeyVariants,
  testAllHashCombinations,
  isHashCheckDisabled 
};